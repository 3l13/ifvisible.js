// Generated by CoffeeScript 1.6.2
/*
Copyright (c) 2013 Serkan Yersen

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/


(function() {
  "use strict";
  /*
  Export Object
  @type {Object}
  */

  var addEvent, customEvent, doc, fireEvent, hidden, idleStartedTime, idleTime, ie, ifvisible, init, initialized, status, trackIdleStatus, visibilityChange;

  ifvisible = {};

  /*
  document element
  @type {Document Object}
  */


  doc = document;

  /*
  flag to prevent multiple initializations
  @type {Boolean}
  */


  initialized = false;

  /*
  Current status, may contain "active", "idle", "hidden"
  @type {String}
  */


  status = "active";

  /*
  Time to wait when setting page to idle
  @type {Number} in miliseconds
  */


  idleTime = 60000;

  /*
  To track how many time left to become IDLE I need to know
  when we started keeping the time
  @type {Number} in miliseconds
  */


  idleStartedTime = false;

  /*
  Handle Custom Object events
  @return {Object} add and fire methods to handle custom events
  */


  customEvent = (function() {
    /*
    Create a synthetic GUID
    */

    var S4, addCustomEvent, customGUID, fireCustomEvent, guid, listeners;

    S4 = function() {
      return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
    };
    guid = function() {
      return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
    };
    /*
    Event listeners
    @type {Object}
    */

    listeners = {};
    /*
    Name of the custom GUID property
    @type {String}
    */

    customGUID = '__ceGUID';
    /*
    Add a custom event to a given object
    @param {Object}   obj      Object to add custom events
    @param {string}   event    name of the custom event
    @param {Function} callback callback function to run when event is fired
    */

    addCustomEvent = function(obj, event, callback) {
      obj[customGUID] = undefined;
      if (!obj[customGUID]) {
        obj[customGUID] = "ifvisible.object.event.identifier";
      }
      if (!listeners[obj[customGUID]]) {
        listeners[obj[customGUID]] = {};
      }
      if (!listeners[obj[customGUID]][event]) {
        listeners[obj[customGUID]][event] = [];
      }
      return listeners[obj[customGUID]][event].push(callback);
    };
    /*
    Trigger the custom event on given object
    @param  {Object} obj   Object to trigger the event
    @param  {string} event name of the event to trigger
    @param  {object} memo  a custom argument to send triggered event
    */

    fireCustomEvent = function(obj, event, memo) {
      var ev, _i, _len, _ref, _results;

      if (obj[customGUID] && listeners[obj[customGUID]] && listeners[obj[customGUID]][event]) {
        _ref = listeners[obj[customGUID]][event];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          ev = _ref[_i];
          _results.push(ev(memo || {}));
        }
        return _results;
      }
    };
    return {
      add: addCustomEvent,
      fire: fireCustomEvent
    };
  })();

  /*
  CrossBrowser event attachement
  @param  {DomElement}   el Dom Element to attach the event
  @param  {string}   ev name of the event with on prefix
  @param  {Function} fn callback function to run when event is fired
  */


  addEvent = (function() {
    var setListener;

    setListener = false;
    return function(el, ev, fn) {
      if (!setListener) {
        if (el.addEventListener) {
          setListener = function(el, ev, fn) {
            return el.addEventListener(ev, fn, false);
          };
        } else if (el.attachEvent) {
          setListener = function(el, ev, fn) {
            return el.attachEvent(ev, fn, false);
          };
        } else {
          setListener = function(el, ev, fn) {
            return el['on' + ev] = fn;
          };
        }
      }
      return setListener(el, ev, fn);
    };
  })();

  /*
  Trigger any HTML events
  @param  {DomElement} element Dom Element to trigger events on
  @param  {string} event   event name to trigger
  @return {boolean}   if dispached or not
  */


  fireEvent = function(element, event) {
    var evt;

    if (doc.createEventObject) {
      return element.fireEvent('on' + event, evt);
    } else {
      evt = doc.createEvent('HTMLEvents');
      evt.initEvent(event, true, true);
      return !element.dispatchEvent(evt);
    }
  };

  /*
  Get the IE version
  @return {Number|Undefined} version number of IE or undefined
  */


  ie = (function() {
    var all, check, div, undef, v;

    undef = void 0;
    v = 3;
    div = doc.createElement("div");
    all = div.getElementsByTagName("i");
    check = function() {
      return (div.innerHTML = "<!--[if gt IE " + (++v) + "]><i></i><![endif]-->", all[0]);
    };
    while (check()) {
      continue;
    }
    if (v > 4) {
      return v;
    } else {
      return undef;
    }
  })();

  /*
  Set the name of the hidden property and the change event for visibility checks
  */


  hidden = false;

  visibilityChange = void 0;

  if (typeof doc.hidden !== "undefined") {
    hidden = "hidden";
    visibilityChange = "visibilitychange";
  } else if (typeof doc.mozHidden !== "undefined") {
    hidden = "mozHidden";
    visibilityChange = "mozvisibilitychange";
  } else if (typeof doc.msHidden !== "undefined") {
    hidden = "msHidden";
    visibilityChange = "msvisibilitychange";
  } else if (typeof doc.webkitHidden !== "undefined") {
    hidden = "webkitHidden";
    visibilityChange = "webkitvisibilitychange";
  }

  /*
  Track if the page is idle or not
  */


  trackIdleStatus = function() {
    var timer, wakeUp;

    timer = false;
    wakeUp = function() {
      clearTimeout(timer);
      if (status !== "active") {
        ifvisible.wakeup();
      }
      idleStartedTime = +(new Date());
      return timer = setTimeout(function() {
        if (status === "active") {
          return ifvisible.idle();
        }
      }, idleTime);
    };
    wakeUp();
    addEvent(doc, "mousemove", wakeUp);
    addEvent(doc, "keyup", wakeUp);
    addEvent(window, "scroll", wakeUp);
    return ifvisible.focus(wakeUp);
  };

  /*
  Initialize the module
  @constructor
  */


  init = function() {
    var blur;

    if (initialized) {
      return true;
    }
    if (hidden === false) {
      blur = "blur";
      if (ie < 9) {
        blur = "focusout";
      }
      addEvent(window, blur, function() {
        return ifvisible.blur();
      });
      addEvent(window, "focus", function() {
        return ifvisible.focus();
      });
    } else {
      addEvent(doc, visibilityChange, function() {
        if (doc[hidden]) {
          return ifvisible.blur();
        } else {
          return ifvisible.focus();
        }
      }, false);
    }
    initialized = true;
    return trackIdleStatus();
  };

  /*
  Methods to be exported
  @type {Object}
  */


  ifvisible = {
    /*
    Change idle timeout value.
    @param {Number} seconds a number in seconds such as: 10 or 0.5
    */

    setIdleDuration: function(seconds) {
      return idleTime = seconds * 1000;
    },
    /*
    Get idle timeout value.
    */

    getIdleDuration: function() {
      return idleTime;
    },
    /*
    GEt information about user being idle.
    @return {Object} An object contining information about idle status, informations is as following
    <pre>
      isIdle = [current idle status true/false]
      idleFor = [how long the user was idle in milliseconds]
      timeLeft = [How long does it take to become idle in milliseconds]
      timeLeftPer = [How long does it take to become idle in percentage]
    </pre>
    */

    getIdleInfo: function() {
      var now, response;

      now = +(new Date());
      response = {};
      if (status === "idle") {
        response.isIdle = true;
        response.idleFor = now - idleStartedTime;
        response.timeLeft = 0;
        response.timeLeftPer = 100;
      } else {
        response.isIdle = false;
        response.idleFor = now - idleStartedTime;
        response.timeLeft = (idleStartedTime + idleTime) - now;
        response.timeLeftPer = (100 - (response.timeLeft * 100 / idleTime)).toFixed(2);
      }
      return response;
    },
    /*
    When User Opens the page,
    @note: User may not be looking at it directly
    */

    focus: function(callback) {
      if (typeof callback === "function") {
        return this.on("focus", callback);
      }
      status = "active";
      customEvent.fire(this, "focus");
      customEvent.fire(this, "wakeup");
      return customEvent.fire(this, "statusChanged", {
        status: status
      });
    },
    /*
    When User swicthes tabs or minimizes the window
    @note: this may trigger when iframes are selected
    */

    blur: function(callback) {
      if (typeof callback === "function") {
        return this.on("blur", callback);
      }
      status = "hidden";
      customEvent.fire(this, "blur");
      customEvent.fire(this, "idle");
      return customEvent.fire(this, "statusChanged", {
        status: status
      });
    },
    /*
    When page is focused but user is doing nothing on the page
    */

    idle: function(callback) {
      if (typeof callback === "function") {
        return this.on("idle", callback);
      }
      status = "idle";
      customEvent.fire(this, "idle");
      return customEvent.fire(this, "statusChanged", {
        status: status
      });
    },
    /*
    When user started to make interactions on the page such as:
    mousemove, click, keypress, scroll
    This will be called when page has focus too
    */

    wakeup: function(callback) {
      if (typeof callback === "function") {
        return this.on("wakeup", callback);
      }
      status = "active";
      customEvent.fire(this, "wakeup");
      return customEvent.fire(this, "statusChanged", {
        status: status
      });
    },
    /*
    Set an event to ifvisible object
    @param  {string}   name     Event name such as focus, idle, blur, wakeup
    @param  {Function} callback callback function to call ben event is fired
    @return {object}            an object with a stop method to unbid this event
    */

    on: function(name, callback) {
      init();
      return customEvent.add(this, name, callback);
    },
    /*
    if page is visible then run this given code in given seconds intervals
    @param  {float}   seconds  seconds to run interval
    @param  {Function} callback callback function to run
    */

    onEvery: function(seconds, callback) {
      var t;

      init();
      t = setInterval(function() {
        if (status === "active") {
          return callback();
        }
      }, seconds * 1000);
      return {
        stop: function() {
          return clearInterval(t);
        },
        code: t,
        callback: callback
      };
    },
    /*
    ifvisible.now() return if the page is visible right now?
    @return {boolean} true if page is visible
    */

    now: function() {
      init();
      return status === "active";
    }
  };

  if (typeof define === "function" && define.amd) {
    define(function() {
      return ifvisible;
    });
  } else {
    window.ifvisible = ifvisible;
  }

  /* compile code: `coffee -wcm ifvisible.coffee`
  */


}).call(this);

/*
//@ sourceMappingURL=ifvisible.map
*/
